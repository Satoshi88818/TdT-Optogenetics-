#!/usr/bin/env python3

"""
Lab-Ready Optogenetic TdT DNA Synthesis Simulator (v5.0 - Enhanced)

Enhancements in v5.0:
- Configurable target sequence via CLI (--target)
- Homopolymer run-length tracking (max run per strand + ensemble stats)
- Usable yield metrics: exact, length-tolerant (±1 nt exact sequence), and low-error (Hamming ≤1)
- Optional dNTP consumption tracking per phase
- Irreversible deblocking failure for reversible terminators (--deblock-efficiency)
- Simple parameter sweep mode (--sweep)
- Minor performance optimizations in rate calculation
"""

import numpy as np
import matplotlib.pyplot as plt
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO
from collections import defaultdict, Counter
import multiprocessing as mp
import argparse
import os
import itertools

# Physical constants
AVOGADRO = 6.022e23
FEMTOLITER = 1e-15
MOLECULES_PER_uM_fL = AVOGADRO * FEMTOLITER * 1e-6  # ~602 molecules/µM in 1 fL

# Light pulse schedule (10% duty cycle)
PULSE_ON = 1.0    # seconds
PULSE_OFF = 9.0   # seconds
CYCLE_TIME = PULSE_ON + PULSE_OFF


def compute_max_homopolymer_run(seq_str: str) -> int:
    if not seq_str:
        return 0
    max_run = 1
    current_run = 1
    for i in range(1, len(seq_str)):
        if seq_str[i] == seq_str[i-1]:
            current_run += 1
            max_run = max(max_run, current_run)
        else:
            current_run = 1
    return max_run


def hamming_distance(s1: str, s2: str) -> int:
    return sum(a != b for a, b in zip(s1, s2))


class GillespieSimulator:
    def __init__(
        self,
        cell_volume_fl=800.0,
        num_initiators=1000,
        tdT_conc_uM=0.8,
        dNTP_conc_uM=300.0,
        k_cat_base=8.0,
        Km_uM=100.0,
        cofactor='Co',
        pulses_per_phase=2,
        use_reversible_terminators=False,
        terminator_efficiency=0.99,
        deblock_efficiency=1.0,  # New: fraction that successfully deblock (1.0 = perfect)
        stall_length_threshold=15,
        stall_rate_factor=0.2,
        track_sequences=True,
        cycle_mode='mixed',
        bias_ratio=20.0,
        wash_inefficiency=0.001,
        max_extension_factor=10,
        activation_mode='dimer',
        dark_leak_dimer=0.05,
        track_consumption=False,
    ):
        self.cell_volume_fl = cell_volume_fl
        self.num_initiators = num_initiators
        self.pulses_per_phase = pulses_per_phase
        self.phase_duration = pulses_per_phase * CYCLE_TIME
        self.use_reversible_terminators = use_reversible_terminators
        self.terminator_efficiency = terminator_efficiency
        self.deblock_efficiency = deblock_efficiency
        self.track_sequences = track_sequences
        self.cycle_mode = cycle_mode
        self.bias_ratio = bias_ratio
        self.wash_inefficiency = wash_inefficiency
        self.max_extension_factor = max_extension_factor
        self.activation_mode = activation_mode
        self.dark_leak_dimer = dark_leak_dimer
        self.track_consumption = track_consumption

        self.TdT_total = max(1, int(tdT_conc_uM * MOLECULES_PER_uM_fL * cell_volume_fl))

        self.k_cat_base = k_cat_base
        self.Km_uM = Km_uM
        self.Kd_light = 1.0
        self.Kd_dark = 100.0

        base_prefs = {'A': 1.2, 'C': 0.8, 'G': 1.5, 'T': 0.7}  # Mg-like
        if cofactor == 'Co':
            base_prefs = {'A': 1.0, 'C': 1.3, 'G': 1.1, 'T': 1.2}
        self.base_pref_factors = base_prefs

        self.stall_length_threshold = stall_length_threshold
        self.stall_rate_factor = stall_rate_factor
        self.max_rate_per_molecule = 100.0

        self.dNTP_conc_uM = dNTP_conc_uM
        self.molecules_per_uM = MOLECULES_PER_uM_fL * cell_volume_fl

        self.prev_dNTP_mols = {'A': 0, 'C': 0, 'G': 0, 'T': 0}

    def light_on(self, t, phase_start):
        return (t - phase_start) % CYCLE_TIME < PULSE_ON

    def run_single_cell(self, target_seq, seed=None):
        rng = np.random.default_rng(seed)

        lengths = np.zeros(self.num_initiators, dtype=int)
        blocked = np.full(self.num_initiators, False)          # Reversible block
        permanently_blocked = np.full(self.num_initiators, False)  # Irreversible
        sequences = [""] * self.num_initiators if self.track_sequences else None

        t = 0.0
        light_exposure = 0.0
        times = [t]
        avg_lengths = [0.0]
        target_len = len(target_seq)
        target_str = str(target_seq)

        bases = ['A', 'C', 'G', 'T']
        consumption_per_phase = [] if self.track_consumption else None

        for pos in range(target_len + int(target_len * 1.5)):  # Increased over-extension allowance
            current_base = target_seq[pos] if pos < target_len else rng.choice(bases)
            phase_start = t

            dNTP_molecules = {'A': 0, 'C': 0, 'G': 0, 'T': 0}
            carry = self.prev_dNTP_mols.copy()
            for b in bases:
                carry[b] *= self.wash_inefficiency

            if self.cycle_mode == 'target_only':
                conc = self.dNTP_conc_uM
                dNTP_molecules[current_base] = max(1, int(conc * self.molecules_per_uM))
            elif self.cycle_mode == 'high_bias':
                correct_conc = self.dNTP_conc_uM * self.bias_ratio / (self.bias_ratio + 3)
                wrong_conc = self.dNTP_conc_uM / (self.bias_ratio + 3)
                dNTP_molecules[current_base] = max(1, int(correct_conc * self.molecules_per_uM))
                for b in bases:
                    if b != current_base:
                        dNTP_molecules[b] = max(1, int(wrong_conc * self.molecules_per_uM))
            else:  # mixed
                conc = self.dNTP_conc_uM / 4
                for b in bases:
                    dNTP_molecules[b] = max(1, int(conc * self.molecules_per_uM))

            for b in bases:
                dNTP_molecules[b] += int(carry[b])

            initial_dNTP_this_phase = sum(dNTP_molecules.values())
            if initial_dNTP_this_phase == 0:
                break

            # Deblock reversible terminators
            if self.use_reversible_terminators:
                # Attempt deblock on reversibly blocked
                deblock_success = rng.random(self.num_initiators) < self.deblock_efficiency
                blocked &= ~deblock_success  # Successful ones unblock
                permanently_blocked |= blocked & ~deblock_success  # Failed deblock -> permanent
                blocked.fill(False)  # Clear reversible blocks after attempt

            while (t - phase_start) < self.phase_duration:
                light_active = self.light_on(t, phase_start)

                if self.activation_mode == 'dimer':
                    light_factor = 1.0 if light_active else 0.0
                    Kd_eff = self.Kd_light * light_factor + self.Kd_dark * (1 - light_factor)
                    fraction_active = self.dark_leak_dimer + (1 - self.dark_leak_dimer) / (1 + Kd_eff)
                elif self.activation_mode == 'caged_cofactor':
                    fraction_active = 1.0 if light_active else 0.01

                active_TdT = fraction_active * self.TdT_total

                eligible = (lengths < target_len * self.max_extension_factor) & ~permanently_blocked
                if self.use_reversible_terminators:
                    eligible &= ~blocked
                num_eligible = np.sum(eligible)
                total_dNTP = sum(dNTP_molecules.values())
                if num_eligible == 0 or total_dNTP <= 0:
                    break

                conc_uM = {b: dNTP_molecules[b] / self.molecules_per_uM for b in bases}
                total_conc_uM = sum(conc_uM.values())
                mm_factor = total_conc_uM / (total_conc_uM + self.Km_uM) if total_conc_uM > 0 else 0.0

                rate_per_eligible_light = self.k_cat_base * mm_factor * active_TdT / num_eligible
                dark_k_cat = self.k_cat_base * 0.05
                dark_rate_per_mol = dark_k_cat * mm_factor * (self.TdT_total - active_TdT) / self.num_initiators

                rates = np.full(self.num_initiators, dark_rate_per_mol)

                # Vectorized light contribution
                if num_eligible > 0 and total_conc_uM > 0:
                    probs = np.array([conc_uM[b] * self.base_pref_factors[b] for b in bases])
                    probs /= probs.sum()
                    light_add = rate_per_eligible_light * probs[:, np.newaxis]
                    rates[eligible] += np.sum(light_add[:, eligible], axis=0)

                stalled = lengths >= self.stall_length_threshold
                rates[stalled] *= self.stall_rate_factor
                rates = np.minimum(rates, self.max_rate_per_molecule)

                total_rate = rates.sum()
                if total_rate <= 0:
                    break

                tau = rng.exponential(1 / total_rate)
                next_t = t + tau
                if light_active:
                    light_exposure += min(tau, PULSE_ON - (t - phase_start) % CYCLE_TIME)

                t = min(next_t, phase_start + self.phase_duration)
                if t >= phase_start + self.phase_duration:
                    break

                idx = rng.choice(self.num_initiators, p=rates / total_rate)

                if light_active and rng.random() < fraction_active:
                    probs = np.array([conc_uM[b] * self.base_pref_factors[b] for b in bases])
                    probs /= probs.sum() if probs.sum() > 0 else 1
                    add_base = rng.choice(bases, p=probs)
                else:
                    add_base = rng.choice(bases)

                if sequences is not None:
                    sequences[idx] += add_base
                lengths[idx] += 1
                dNTP_molecules[add_base] -= 1

                if self.use_reversible_terminators and rng.random() < self.terminator_efficiency:
                    blocked[idx] = True

            self.prev_dNTP_mols = dNTP_molecules.copy()

            if self.track_consumption:
                used = initial_dNTP_this_phase - sum(dNTP_molecules.values())
                consumption_per_phase.append((pos, current_base, used))

            times.append(t)
            avg_lengths.append(lengths.mean())

        result = {
            'times': times,
            'avg_lengths': avg_lengths,
            'final_lengths': lengths.tolist(),
            'final_avg_extension': lengths.mean(),
            'total_time': t,
            'light_exposure': light_exposure,
            'total_nt_added': int(lengths.sum()),
        }

        if self.track_sequences:
            pos_correct = defaultdict(int)
            pos_total = defaultdict(int)
            perfect_count = 0
            exact_len_count = 0
            len_tolerant_count = 0
            low_error_count = 0
            max_runs = []

            for seq_str in sequences:
                seq_len = len(seq_str)
                max_runs.append(compute_max_homopolymer_run(seq_str))

                correct_up_to = 0
                for i, b in enumerate(seq_str):
                    pos_total[i] += 1
                    if i < target_len and b == target_str[i]:
                        pos_correct[i] += 1
                        correct_up_to += 1

                if seq_len == target_len and correct_up_to == target_len:
                    perfect_count += 1

                # Usable yield metrics
                if seq_len == target_len and hamming_distance(seq_str, target_str) == 0:
                    exact_len_count += 1

                if abs(seq_len - target_len) <= 1 and seq_str[:target_len] == target_str:
                    len_tolerant_count += 1

                min_ham = min(hamming_distance(seq_str[:target_len], target_str), 
                              hamming_distance(seq_str[:target_len-1], target_str) if seq_len >= target_len-1 else float('inf'),
                              hamming_distance(seq_str[:target_len+1], target_str) if seq_len >= target_len+1 else float('inf'))
                if min_ham <= 1:
                    low_error_count += 1

            per_pos_acc = {p: pos_correct[p] / pos_total[p] if pos_total[p] > 0 else 1.0 for p in sorted(pos_correct)}
            overall_acc = sum(pos_correct.values()) / sum(pos_total.values()) if sum(pos_total.values()) > 0 else 1.0

            result.update({
                'final_sequences': sequences,
                'per_pos_accuracy': per_pos_acc,
                'overall_base_accuracy': overall_acc,
                'perfect_fraction': perfect_count / self.num_initiators,
                'exact_target_fraction': exact_len_count / self.num_initiators,
                'len_tolerant_yield': len_tolerant_count / self.num_initiators,
                'low_error_yield': low_error_count / self.num_initiators,
                'max_homopolymer_runs': max_runs,
                'mean_max_homopolymer': np.mean(max_runs),
                'max_max_homopolymer': np.max(max_runs),
            })

            if self.track_consumption:
                result['consumption_per_phase'] = consumption_per_phase

        return result

    def run_ensemble(self, target_seq, num_cells=20, seed_base=123):
        seeds = [seed_base + i for i in range(num_cells)]
        with mp.Pool(os.cpu_count()) as pool:
            results = pool.starmap(self.run_single_cell, [(target_seq, s) for s in seeds])
        return results


def run_parameter_sweep(args):
    bias_ratios = [10, 20, 50]
    pulses_list = [1, 2, 4]
    term_eff_list = [0.95, 0.99, 1.0] if args.mode == 'terminator' else [None]

    results = []
    for br, pp, te in itertools.product(bias_ratios, pulses_list, term_eff_list):
        print(f"\nSweep: bias_ratio={br}, pulses_per_phase={pp}, terminator_eff={te or 'N/A'}")
        sim = GillespieSimulator(
            pulses_per_phase=pp,
            cofactor=args.cofactor,
            cycle_mode='high_bias' if args.mode in ['high_bias', 'terminator'] else args.mode,
            bias_ratio=br,
            use_reversible_terminators=args.mode == 'terminator',
            terminator_efficiency=te or 0.99,
            activation_mode=args.activation,
            track_sequences=True,
            track_consumption=False,
        )
        ensemble = sim.run_ensemble(Seq(args.target), num_cells=args.cells)
        perf = np.mean([r['perfect_fraction'] for r in ensemble])
        acc = np.mean([r['overall_base_accuracy'] for r in ensemble])
        low_err = np.mean([r['low_error_yield'] for r in ensemble])
        print(f"  Perfect: {perf:.4f} | Acc: {acc:.3f} | Low-error yield: {low_err:.3f}")
        results.append((br, pp, te, perf, acc, low_err))
    return results


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Optogenetic TdT DNA synthesis simulator v5.0")
    parser.add_argument('--target', type=str, default="ATCGATCGATCGATCGATCG",
                        help='Target sequence to synthesize (DNA string)')
    parser.add_argument('--mode', choices=['mixed', 'target_only', 'high_bias', 'terminator'], default='mixed')
    parser.add_argument('--cells', type=int, default=20)
    parser.add_argument('--pulses', type=int, default=2)
    parser.add_argument('--cofactor', choices=['Mg', 'Co'], default='Co')
    parser.add_argument('--activation', choices=['dimer', 'caged_cofactor'], default='dimer')
    parser.add_argument('--deblock-efficiency', type=float, default=1.0,
                        help='Fraction of reversible terminators that successfully deblock (1.0 = perfect)')
    parser.add_argument('--track-consumption', action='store_true')
    parser.add_argument('--save_plots', action='store_true')
    parser.add_argument('--sweep', action='store_true', help='Run simple parameter sweep instead of single run')
    args = parser.parse_args()

    target_seq = Seq(args.target.upper())

    if args.sweep:
        run_parameter_sweep(args)
        exit(0)

    if args.mode == 'terminator':
        cycle_mode = 'high_bias'
        use_terminators = True
    else:
        cycle_mode = args.mode
        use_terminators = False

    sim = GillespieSimulator(
        pulses_per_phase=args.pulses,
        cofactor=args.cofactor,
        cycle_mode=cycle_mode,
        use_reversible_terminators=use_terminators,
        terminator_efficiency=0.99,
        deblock_efficiency=args.deblock_efficiency,
        activation_mode=args.activation,
        track_sequences=True,
        track_consumption=args.track_consumption,
    )

    print(f"Target: {target_seq}")
    print(f"Running {args.cells}-cell ensemble | Mode: {args.mode} | Terminators: {use_terminators} | "
          f"Deblock eff: {args.deblock_efficiency}")

    ensemble = sim.run_ensemble(target_seq, num_cells=args.cells)

    # Ensemble summary
    perfects = [r['perfect_fraction'] for r in ensemble]
    accuracies = [r['overall_base_accuracy'] for r in ensemble]
    low_error = [r['low_error_yield'] for r in ensemble]
    len_tol = [r['len_tolerant_yield'] for r in ensemble]
    mean_max_runs = [r['mean_max_homopolymer'] for r in ensemble]

    print("\nEnsemble Summary:")
    print(f"  Perfect fraction:           {np.mean(perfects):.4f} ± {np.std(perfects):.4f}")
    print(f"  Overall base accuracy:     {np.mean(accuracies):.3f} ± {np.std(accuracies):.3f}")
    print(f"  ±1 nt exact yield:         {np.mean(len_tol):.4f} ± {np.std(len_tol):.4f}")
    print(f"  Low-error (Hamming ≤1) yield: {np.mean(low_error):.4f} ± {np.std(low_error):.4f}")
    print(f"  Mean max homopolymer run:  {np.mean(mean_max_runs):.2f} nt")

    # Plots (representative cell)
    ex = ensemble[0]
    # ... (trajectory, length dist, per-pos accuracy plots unchanged for brevity)

    # FASTA export with enhanced metadata
    all_sequences = []
    target_len = len(target_seq)
    target_str = str(target_seq)

    for cell_idx, res in enumerate(ensemble):
        if 'final_sequences' not in res:
            continue
        for init_idx, seq_str in enumerate(res['final_sequences']):
            seq = Seq(seq_str)
            desc = f"cell={cell_idx} init={init_idx} len={len(seq)} max_run={compute_max_homopolymer_run(seq_str)}"
            ham = hamming_distance(seq_str[:target_len], target_str)
            desc += f" ham={ham}"
            if ham == 0 and len(seq) == target_len:
                desc += " PERFECT"
            rec = SeqRecord(seq, id=f"synth_{cell_idx:03d}_{init_idx:05d}", description=desc)
            all_sequences.append(rec)

    output_fasta = "synthesized_strands_v5.fasta"
    SeqIO.write(all_sequences, output_fasta, "fasta")
    print(f"\nExported {len(all_sequences)} sequences to {output_fasta}")