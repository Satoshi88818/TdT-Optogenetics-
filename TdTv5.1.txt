#!/usr/bin/env python3

"""
Lab-Ready Optogenetic TdT DNA Synthesis Simulator (v5.1 - Performance Optimized)

New in v5.1:
- Hybrid simulation: Poisson batch additions for correct base in biased light-on phases
- Correct carry-over for all dNTPs
- Reduced over-extension loop range
- Robust prob normalization
"""

import numpy as np
import matplotlib.pyplot as plt
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO
from collections import defaultdict, Counter
import multiprocessing as mp
import argparse
import os
import itertools

# Physical constants
AVOGADRO = 6.022e23
FEMTOLITER = 1e-15
MOLECULES_PER_uM_fL = AVOGADRO * FEMTOLITER * 1e-6

# Light pulse schedule (10% duty cycle)
PULSE_ON = 1.0
PULSE_OFF = 9.0
CYCLE_TIME = PULSE_ON + PULSE_OFF


def compute_max_homopolymer_run(seq_str: str) -> int:
    if not seq_str:
        return 0
    max_run = 1
    current_run = 1
    for i in range(1, len(seq_str)):
        if seq_str[i] == seq_str[i-1]:
            current_run += 1
            max_run = max(max_run, current_run)
        else:
            current_run = 1
    return max_run


def hamming_distance(s1: str, s2: str) -> int:
    return sum(a != b for a, b in zip(s1, s2))


class GillespieSimulator:
    def __init__(
        self,
        cell_volume_fl=800.0,
        num_initiators=1000,
        tdT_conc_uM=0.8,
        dNTP_conc_uM=300.0,
        k_cat_base=8.0,
        Km_uM=100.0,
        cofactor='Co',
        pulses_per_phase=2,
        use_reversible_terminators=False,
        terminator_efficiency=0.99,
        deblock_efficiency=1.0,
        stall_length_threshold=15,
        stall_rate_factor=0.2,
        track_sequences=True,
        cycle_mode='mixed',
        bias_ratio=20.0,
        wash_inefficiency=0.001,
        max_extension_factor=10,
        activation_mode='dimer',
        dark_leak_dimer=0.05,
        track_consumption=False,
    ):
        # ... (unchanged params)
        self.fast_depletion_threshold = 0.2  # Switch off fast approx when correct dNTP depleted below this fraction

        # ... (rest unchanged)

    def run_single_cell(self, target_seq, seed=None):
        rng = np.random.default_rng(seed)

        # ... (initialization unchanged)

        for pos in range(target_len + int(target_len * 0.5)):  # Reduced over-extension
            # ... (dNTP setup and carry-over for ALL bases - fixed)

            for b in bases:
                dNTP_molecules[b] += int(carry[b])

            initial_correct = dNTP_molecules.get(current_base, 0)
            # ... (deblock unchanged)

            phase_time_spent = 0.0
            use_fast_approx = self.cycle_mode in ('target_only', 'high_bias')

            while phase_time_spent < self.phase_duration:
                # ... (light_active, fraction_active, eligible, mm_factor unchanged)

                if use_fast_approx and light_active and num_eligible > 0 and total_conc_uM > 0:
                    probs = np.array([conc_uM[b] * self.base_pref_factors[b] for b in bases])
                    probs_sum = probs.sum()
                    if probs_sum == 0:
                        probs.fill(1/4)
                    else:
                        probs /= probs_sum
                    p_correct = probs[bases.index(current_base)]

                    if p_correct > 0.5 and initial_correct > 0 and (dNTP_molecules[current_base] / initial_correct > self.fast_depletion_threshold):
                        eligible_stall = stall_factors[eligible]
                        light_rate_per_eligible = rate_per_eligible_light * eligible_stall
                        correct_rate_total = light_rate_per_eligible.sum() * p_correct + dark_rate_per_mol * p_correct * num_eligible

                        if correct_rate_total > 0:
                            tau = rng.exponential(1 / correct_rate_total)
                            if tau > remaining_phase:
                                # advance to end of phase
                                t += remaining_phase
                                phase_time_spent += remaining_phase
                                if light_active:
                                    light_exposure += remaining_phase
                                break

                            num_add = rng.poisson(correct_rate_total * tau)
                            num_add = min(num_add, num_eligible, dNTP_molecules[current_base])

                            if num_add > 0:
                                candidates = np.flatnonzero(eligible)
                                chosen = rng.choice(candidates, size=num_add, replace=False)
                                lengths[chosen] += 1
                                if sequences is not None:
                                    for idx in chosen:
                                        sequences[idx] += current_base
                                dNTP_molecules[current_base] -= num_add

                                if self.use_reversible_terminators:
                                    block_roll = rng.random(num_add) < self.terminator_efficiency
                                    blocked[chosen[block_roll]] = True

                            t += tau
                            phase_time_spent += tau
                            light_exposure += tau
                            continue

                # Full vectorized Gillespie fallback (updated to add per-base contrib correctly)
                rates = np.full(self.num_initiators, dark_rate_per_mol * stall_factors)

                if num_eligible > 0 and total_conc_uM > 0:
                    probs = np.array([conc_uM[b] * self.base_pref_factors[b] for b in bases])
                    probs /= probs.sum() if probs.sum() > 0 else 1
                    light_contrib_per_mol = rate_per_eligible_light * stall_factors[eligible]
                    rates[eligible] += np.dot(probs, light_contrib_per_mol)  # vectorized

                # ... (rest of event selection unchanged)

        # ... (result compilation unchanged)

# The rest of the script (parameter sweep, CLI, ensemble summary, FASTA export) remains identical.

if __name__ == "__main__":
    # ... (unchanged)